import { Assert } from '@japa/assert';
import Macroable from '@poppinss/macroable';
import { type HTTPError, Response } from 'superagent';
import { ApiRequest } from './request.js';
import { RequestConfig, ResponseCookie, ResponseCookies, SuperAgentResponseFile } from './types.js';
export declare class ApiResponse extends Macroable {
    #private;
    request: ApiRequest;
    response: Response;
    protected config: RequestConfig;
    assert?: Assert | undefined;
    /**
     * Parsed cookies
     */
    cookiesJar: ResponseCookies;
    constructor(request: ApiRequest, response: Response, config: RequestConfig, assert?: Assert | undefined);
    /**
     * Response content-type charset. Undefined if no charset
     * is mentioned.
     */
    charset(): string | undefined;
    /**
     * Parsed files from the multipart response.
     */
    files<Properties extends string>(): {
        [K in Properties]: SuperAgentResponseFile;
    };
    /**
     * Returns an object of links by parsing the "Link" header.
     *
     * @example
     * Link: <https://one.example.com>; rel="preconnect", <https://two.example.com>; rel="preload"
     * response.links()
     * // {
     * //   preconnect: 'https://one.example.com',
       //   preload: 'https://two.example.com',
     * // }
     */
    links(): Record<string, string>;
    /**
     * Response status type
     */
    statusType(): number;
    /**
     * Request raw parsed text
     */
    text(): string;
    /**
     * Response body
     */
    body(): any;
    /**
     * Read value for a given response header
     */
    header(key: string): string | undefined;
    /**
     * Get all response headers
     */
    headers(): Record<string, string>;
    /**
     * Get response status
     */
    status(): number;
    /**
     * Get response content-type
     */
    type(): string;
    /**
     * Get redirects URLs the request has followed before
     * getting the response
     */
    redirects(): string[];
    /**
     * Find if the response has parsed body. The check is performed
     * by inspecting the response content-type and returns true
     * when content-type is either one of the following.
     *
     * - application/json
     * - application/x-www-form-urlencoded
     * - multipart/form-data
     *
     * Or when the response body is a buffer.
     */
    hasBody(): boolean;
    /**
     * Find if the response body has files
     */
    hasFiles(): boolean;
    /**
     * Find if response is an error
     */
    hasError(): boolean;
    /**
     * Find if response is an fatal error. Response with >=500
     * status code are concerned as fatal errors
     */
    hasFatalError(): boolean;
    /**
     * Find if the request client failed to make the request
     */
    hasClientError(): boolean;
    /**
     * Find if the server responded with an error
     */
    hasServerError(): boolean;
    /**
     * Access to response error
     */
    error(): false | HTTPError;
    /**
     * Get cookie by name
     */
    cookie(name: string): ResponseCookie | undefined;
    /**
     * Parsed response cookies
     */
    cookies(): ResponseCookies;
    /**
     * Dump request headers
     */
    dumpHeaders(): this;
    /**
     * Dump request cookies
     */
    dumpCookies(): this;
    /**
     * Dump request body
     */
    dumpBody(): this;
    /**
     * Dump request body
     */
    dumpError(): this;
    /**
     * Dump request
     */
    dump(): this;
    /**
     * Assert response status to match the expected status
     */
    assertStatus(expectedStatus: number): void;
    /**
     * Assert response body to match the expected body
     */
    assertBody(expectedBody: any): void;
    /**
     * Assert response body to match the subset from the
     * expected body
     */
    assertBodyContains(expectedBody: any): void;
    /**
     * Assert response body not to match the subset from the
     * expected body
     */
    assertBodyNotContains(expectedBody: any): void;
    /**
     * Assert response to contain a given cookie and optionally
     * has the expected value
     */
    assertCookie(name: string, value?: any): void;
    /**
     * Assert response to not contain a given cookie
     */
    assertCookieMissing(name: string): void;
    /**
     * Assert response to contain a given header and optionally
     * has the expected value
     */
    assertHeader(name: string, value?: any): void;
    /**
     * Assert response to not contain a given header
     */
    assertHeaderMissing(name: string): void;
    /**
     * Assert response text to include the expected value
     */
    assertTextIncludes(expectedSubset: string): void;
    /**
     * Assert response body is valid as per the API spec.
     */
    assertAgainstApiSpec(): void;
    /**
     * Assert there is a matching redirect
     */
    assertRedirectsTo(pathname: string): void;
    /**
     * Assert that response has an ok (200) status
     */
    assertOk(): void;
    /**
     * Assert that response has a created (201) status
     */
    assertCreated(): void;
    /**
     * Assert that response has an accepted (202) status
     */
    assertAccepted(): void;
    /**
     * Assert that response has a no content (204) status
     */
    assertNoContent(): void;
    /**
     * Assert that response has a moved permanently (301) status
     */
    assertMovedPermanently(): void;
    /**
     * Assert that response has a found (302) status
     */
    assertFound(): void;
    /**
     * Assert that response has a bad request (400) status
     */
    assertBadRequest(): void;
    /**
     * Assert that response has an unauthorized (401) status
     */
    assertUnauthorized(): void;
    /**
     * Assert that response has a payment required (402) status
     */
    assertPaymentRequired(): void;
    /**
     * Assert that response has a forbidden (403) status
     */
    assertForbidden(): void;
    /**
     * Assert that response has a not found (404) status
     */
    assertNotFound(): void;
    /**
     * Assert that response has a method not allowed (405) status
     */
    assertMethodNotAllowed(): void;
    /**
     * Assert that response has a not acceptable (406) status
     */
    assertNotAcceptable(): void;
    /**
     * Assert that response has a request timeout (408) status
     */
    assertRequestTimeout(): void;
    /**
     * Assert that response has a conflict (409) status
     */
    assertConflict(): void;
    /**
     * Assert that response has a gone (410) status
     */
    assertGone(): void;
    /**
     * Assert that response has a length required (411) status
     */
    assertLengthRequired(): void;
    /**
     * Assert that response has a precondition failed (412) status
     */
    assertPreconditionFailed(): void;
    /**
     * Assert that response has a payload too large (413) status
     */
    assertPayloadTooLarge(): void;
    /**
     * Assert that response has a URI too long (414) status
     */
    assertURITooLong(): void;
    /**
     * Assert that response has an unsupported media type (415) status
     */
    assertUnsupportedMediaType(): void;
    /**
     * Assert that response has a range not satisfiable (416) status
     */
    assertRangeNotSatisfiable(): void;
    /**
     * Assert that response has an im a teapot (418) status
     */
    assertImATeapot(): void;
    /**
     * Assert that response has an unprocessable entity (422) status
     */
    assertUnprocessableEntity(): void;
    /**
     * Assert that response has a locked (423) status
     */
    assertLocked(): void;
    /**
     * Assert that response has a too many requests (429) status
     */
    assertTooManyRequests(): void;
}
