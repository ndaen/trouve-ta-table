// src/runner.ts
import Macroable2 from "@poppinss/macroable";

// src/debug.ts
import { debuglog } from "node:util";
var debug_default = debuglog("japa:core");

// src/tracker.ts
import timeSpan from "time-span";
var Tracker = class {
  /**
   * Time tracker to find runner duration
   */
  #timeTracker;
  /**
   * Currently active suite
   */
  #currentSuite;
  /**
   * Currently active group
   */
  #currentGroup;
  /**
   * If the entire run cycle has one or more errors
   */
  #hasError = false;
  #aggregates = {
    total: 0,
    failed: 0,
    passed: 0,
    regression: 0,
    skipped: 0,
    todo: 0
  };
  #duration = 0;
  /**
   * A tree of suites/groups and tests that have failed. They are always nested inside
   * other unless the test groups where used, then suites contains a list of tests
   * directly.
   */
  #failureTree = [];
  #failedTestsTitles = [];
  /**
   * Set reference for the current suite
   */
  #onSuiteStart(payload) {
    this.#currentSuite = {
      name: payload.name,
      type: "suite",
      errors: [],
      children: []
    };
  }
  /**
   * Move suite to the failure tree when the suite
   * has errors
   */
  #onSuiteEnd(payload) {
    if (payload.hasError) {
      this.#currentSuite.errors = payload.errors;
      this.#failureTree.push(this.#currentSuite);
    }
  }
  /**
   * Set reference for the current group
   */
  #onGroupStart(payload) {
    this.#currentGroup = {
      name: payload.title,
      type: "group",
      errors: [],
      children: []
    };
  }
  /**
   * Move suite to the failure tree when the suite
   * has errors
   */
  #onGroupEnd(payload) {
    if (payload.hasError) {
      this.#currentGroup.errors = payload.errors;
      this.#currentSuite.children.push(this.#currentGroup);
    }
  }
  /**
   * In case of failure, track the test inside the current group
   * or the current suite.
   */
  #onTestEnd(payload) {
    this.#aggregates.total++;
    if (payload.isSkipped) {
      this.#aggregates.skipped++;
      return;
    }
    if (payload.isTodo) {
      this.#aggregates.todo++;
      return;
    }
    if (!payload.hasError) {
      if (payload.isFailing) {
        this.#aggregates.regression++;
      } else {
        this.#aggregates.passed++;
      }
      return;
    }
    this.#markTestAsFailed(payload);
  }
  /**
   * Mark test as failed
   */
  #markTestAsFailed(payload) {
    this.#aggregates.failed++;
    const testPayload = {
      type: "test",
      title: payload.title.expanded,
      errors: payload.errors
    };
    if (this.#currentGroup) {
      this.#currentGroup.children.push(testPayload);
    } else if (this.#currentSuite) {
      this.#currentSuite.children.push(testPayload);
    }
    this.#failedTestsTitles.push(payload.title.original);
  }
  /**
   * Process the tests events
   */
  processEvent(event, payload) {
    switch (event) {
      case "suite:start":
        this.#onSuiteStart(payload);
        break;
      case "suite:end":
        this.#onSuiteEnd(payload);
        break;
      case "group:start":
        this.#onGroupStart(payload);
        break;
      case "group:end":
        this.#onGroupEnd(payload);
        break;
      case "test:end":
        this.#onTestEnd(payload);
        break;
      case "runner:start":
        this.#timeTracker = timeSpan();
        break;
      case "runner:end":
        this.#hasError = payload.hasError;
        this.#duration = this.#timeTracker?.rounded() ?? 0;
        break;
    }
  }
  /**
   * Returns the tests runner summary
   */
  getSummary() {
    return {
      aggregates: this.#aggregates,
      hasError: this.#hasError,
      duration: this.#duration,
      failureTree: this.#failureTree,
      failedTestsTitles: this.#failedTestsTitles
    };
  }
};

// src/summary_builder.ts
import string from "@poppinss/string";
import stringWidth from "string-width";
var SummaryBuilder = class {
  #reporters = [];
  /**
   * Register a custom summary reporter
   */
  use(reporter) {
    this.#reporters.push(reporter);
    return this;
  }
  /**
   * Builds the summary table
   */
  build() {
    const keys = [];
    const keysLengths = [];
    const values = [];
    this.#reporters.forEach((reporter) => {
      const reports = reporter();
      reports.forEach((report) => {
        keys.push(report.key);
        values.push(Array.isArray(report.value) ? report.value : [report.value]);
        keysLengths.push(stringWidth(report.key));
      });
    });
    const largestKey = Math.max(...keysLengths);
    const keysRows = string.justify(keys, {
      width: largestKey,
      align: "right",
      indent: " ",
      getLength: (chunk) => stringWidth(chunk)
    });
    return keysRows.map((key, index) => {
      return `${key}${values[index].map((line, i) => {
        return i === 0 ? `  ${line}` : `${" ".repeat(largestKey)}  ${line}`;
      }).join("\n")}`;
    });
  }
};

// src/group/main.ts
import Hooks from "@poppinss/hooks";
import Macroable from "@poppinss/macroable";

// src/group/runner.ts
var GroupRunner = class {
  #options;
  /**
   * Parent group
   */
  #group;
  /**
   * Emitter instance to notify reporters
   */
  #emitter;
  /**
   * Reference to the startup runner
   */
  #setupRunner;
  /**
   * Reference to the cleanup runner
   */
  #teardownRunner;
  /**
   * Test errors
   */
  #errors = [];
  /**
   * Track if execution stack has any errors
   */
  #hasError = false;
  /**
   * Know if any of the tests/hooks have failed
   */
  get failed() {
    return this.#hasError;
  }
  constructor(group, hooks, emitter, options) {
    this.#group = group;
    this.#emitter = emitter;
    this.#options = options;
    this.#setupRunner = hooks.runner("setup");
    this.#teardownRunner = hooks.runner("teardown");
  }
  /**
   * Notify the reporter about the group start
   */
  #notifyStart() {
    const startOptions = { ...this.#group.options };
    this.#emitter.emit("group:start", startOptions);
  }
  /**
   * Notify the reporter about the group end
   */
  #notifyEnd() {
    const endOptions = {
      ...this.#group.options,
      hasError: this.#hasError,
      errors: this.#errors
    };
    this.#emitter.emit("group:end", endOptions);
  }
  /**
   * Running setup hooks
   */
  async #runSetupHooks() {
    try {
      debug_default('running "%s" group setup hooks', this.#group.title);
      await this.#setupRunner.run(this.#group);
    } catch (error) {
      debug_default("group setup hooks failed, group: %s, error: %O", this.#group.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "setup", error });
    }
  }
  /**
   * Running teardown hooks
   */
  async #runTeardownHooks() {
    try {
      debug_default('running "%s" group teardown hooks', this.#group.title);
      await this.#teardownRunner.run(this.#group);
    } catch (error) {
      debug_default("group teardown hooks failed, group: %s, error: %O", this.#group.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "teardown", error });
    }
  }
  /**
   * Running setup cleanup functions
   */
  async #runSetupCleanupFunctions() {
    try {
      debug_default('running "%s" group setup cleanup functions', this.#group.title);
      await this.#setupRunner.cleanup(this.#hasError, this.#group);
    } catch (error) {
      debug_default("group setup cleanup function failed, group: %s, error: %O", this.#group.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "setup:cleanup", error });
    }
  }
  /**
   * Running teardown cleanup functions
   */
  async #runTeardownCleanupFunctions() {
    try {
      debug_default('running "%s" group teardown cleanup functions', this.#group.title);
      await this.#teardownRunner.cleanup(this.#hasError, this.#group);
    } catch (error) {
      debug_default(
        "group teardown cleanup function failed, group: %s, error: %O",
        this.#group.title,
        error
      );
      this.#hasError = true;
      this.#errors.push({ phase: "teardown:cleanup", error });
    }
  }
  /**
   * Run the test
   */
  async run() {
    debug_default('starting to run "%s" group', this.#group.title);
    this.#notifyStart();
    await this.#runSetupHooks();
    if (this.#hasError) {
      await this.#runSetupCleanupFunctions();
      this.#notifyEnd();
      return;
    }
    for (let test of this.#group.tests) {
      if (this.#options.bail && this.#hasError) {
        test.skip(true, "Skipped due to bail mode");
      }
      await test.exec();
      if (!this.#hasError && test.failed) {
        this.#hasError = true;
      }
    }
    await this.#runSetupCleanupFunctions();
    await this.#runTeardownHooks();
    await this.#runTeardownCleanupFunctions();
    this.#notifyEnd();
  }
};

// src/group/main.ts
var Group = class extends Macroable {
  constructor(title, emitter, refiner) {
    super();
    this.title = title;
    this.#emitter = emitter;
    this.#refiner = refiner;
    this.options = {
      title: this.title,
      meta: {}
    };
  }
  #emitter;
  #refiner;
  #failed = false;
  #bail;
  /**
   * Reference to registered hooks
   */
  #hooks = new Hooks();
  /**
   * Callbacks to invoke on each test
   */
  #tapsCallbacks = [];
  /**
   * Properties to configure on every test
   */
  #testsTimeout;
  #testsRetries;
  #testSetupHooks = [];
  #testTeardownHooks = [];
  #testsSkip;
  /**
   * Know if one or more tests/hooks within this group
   * has failed.
   */
  get failed() {
    return this.#failed;
  }
  options;
  /**
   * An array of tests registered under the given group
   */
  tests = [];
  /**
   * Shortcut methods to configure tests
   */
  each = {
    /**
     * Define setup hook for all tests inside the group
     */
    setup: (handler) => {
      this.#testSetupHooks.push(handler);
    },
    /**
     * Define teardown hook for all tests inside the group
     */
    teardown: (handler) => {
      this.#testTeardownHooks.push(handler);
    },
    /**
     * Define timeout for all tests inside the group
     */
    timeout: (timeout) => {
      this.#testsTimeout = timeout;
    },
    /**
     * Disable timeout for all tests inside the group
     */
    disableTimeout: () => {
      this.#testsTimeout = 0;
    },
    /**
     * Define retries for all tests inside the group
     */
    retry: (retries) => {
      this.#testsRetries = retries;
    },
    /**
     * Skip all the tests inside the group
     */
    skip: (skip, skipReason) => {
      this.#testsSkip = { skip: skip ?? true, skipReason };
    }
  };
  /**
   * Enable/disable the bail mode. In bail mode, all
   * upcoming tests will be skipped when the current
   * test fails
   */
  bail(toggle = true) {
    if (this.#bail === void 0) {
      this.#bail = toggle;
    }
    return this;
  }
  /**
   * Add a test to the group. Adding a test to the group
   * mutates the test properties
   */
  add(test) {
    debug_default('adding "%s" test to "%s" group', test.title, this.title);
    if (this.#testsTimeout !== void 0) {
      test.timeout(this.#testsTimeout);
    }
    if (this.#testsRetries !== void 0) {
      test.retry(this.#testsRetries);
    }
    if (this.#testSetupHooks.length) {
      this.#testSetupHooks.forEach((handler) => test.setup(handler));
    }
    if (this.#testTeardownHooks.length) {
      this.#testTeardownHooks.forEach((handler) => test.teardown(handler));
    }
    if (this.#testsSkip) {
      test.skip(this.#testsSkip.skip, this.#testsSkip.skipReason);
    }
    this.#tapsCallbacks.forEach((callback) => callback(test));
    this.tests.push(test);
    return this;
  }
  /**
   * Tap into each test and configure it
   */
  tap(callback) {
    this.tests.forEach((test) => callback(test));
    this.#tapsCallbacks.push(callback);
    return this;
  }
  /**
   * Define setup hook for the group
   */
  setup(handler) {
    debug_default('registering "%s" group setup hook %s', this.title, handler);
    this.#hooks.add("setup", handler);
    return this;
  }
  /**
   * Define teardown hook for the group
   */
  teardown(handler) {
    debug_default('registering "%s" group teardown hook %s', this.title, handler);
    this.#hooks.add("teardown", handler);
    return this;
  }
  /**
   * Execute group hooks and tests
   */
  async exec() {
    if (!this.#refiner.allows(this)) {
      debug_default("group skipped by refined %s", this.title);
      return;
    }
    const runner = new GroupRunner(this, this.#hooks, this.#emitter, {
      bail: this.#bail ?? false
    });
    await runner.run();
    this.#failed = runner.failed;
  }
};

// src/runner.ts
var Runner = class extends Macroable2 {
  #emitter;
  #failed = false;
  #bail = false;
  /**
   * Callbacks to invoke on every suite
   */
  #configureSuiteCallbacks = [];
  /**
   * Reference to tests tracker
   */
  #tracker;
  /**
   * Summary builder is used to create the tests summary reported by
   * multiple reporters. Each report contains a key-value pair
   */
  summaryBuilder = new SummaryBuilder();
  /**
   * A collection of suites
   */
  suites = [];
  /**
   * Registered tests reporter
   */
  reporters = /* @__PURE__ */ new Set();
  constructor(emitter) {
    super();
    this.#emitter = emitter;
  }
  /**
   * Notify the reporter about the runner start
   */
  #notifyStart() {
    return this.#emitter.emit("runner:start", {});
  }
  /**
   * Notify the reporter about the runner end
   */
  #notifyEnd() {
    return this.#emitter.emit("runner:end", {
      hasError: this.#failed
    });
  }
  /**
   * Boot the runner
   */
  #boot() {
    this.#tracker = new Tracker();
    this.#emitter.on(
      "runner:start",
      (payload) => this.#tracker?.processEvent("runner:start", payload)
    );
    this.#emitter.on("runner:end", (payload) => this.#tracker?.processEvent("runner:end", payload));
    this.#emitter.on(
      "suite:start",
      (payload) => this.#tracker?.processEvent("suite:start", payload)
    );
    this.#emitter.on("suite:end", (payload) => this.#tracker?.processEvent("suite:end", payload));
    this.#emitter.on(
      "group:start",
      (payload) => this.#tracker?.processEvent("group:start", payload)
    );
    this.#emitter.on("group:end", (payload) => this.#tracker?.processEvent("group:end", payload));
    this.#emitter.on("test:start", (payload) => this.#tracker?.processEvent("test:start", payload));
    this.#emitter.on("test:end", (payload) => this.#tracker?.processEvent("test:end", payload));
  }
  /**
   * Know if one or more suites have failed
   */
  get failed() {
    return this.#failed;
  }
  /**
   * Add a suite to the runner
   */
  add(suite) {
    this.#configureSuiteCallbacks.forEach((callback) => callback(suite));
    this.suites.push(suite);
    debug_default("registering suite %s", suite.name);
    return this;
  }
  /**
   * Tap into each suite and configure it
   */
  onSuite(callback) {
    this.suites.forEach((suite) => callback(suite));
    this.#configureSuiteCallbacks.push(callback);
    return this;
  }
  /**
   * Enable/disable the bail mode. In bail mode, all
   * upcoming suites/groups/tests will be skipped
   * when the current test fails
   */
  bail(toggle = true) {
    this.#bail = toggle;
    this.onSuite((suite) => suite.bail(toggle));
    return this;
  }
  /**
   * Register a tests reporter
   */
  registerReporter(reporter) {
    this.reporters.add(reporter);
    return this;
  }
  /**
   * Get tests summary
   */
  getSummary() {
    return this.#tracker.getSummary();
  }
  /**
   * Start the test runner process. The method emits
   * "runner:start" event
   */
  async start() {
    this.#boot();
    debug_default("starting to run tests");
    for (let reporter of this.reporters) {
      if (typeof reporter === "function") {
        await reporter(this, this.#emitter);
      } else {
        await reporter.handler(this, this.#emitter);
      }
    }
    await this.#notifyStart();
  }
  /**
   * Execute runner suites
   */
  async exec() {
    for (let suite of this.suites) {
      if (this.#bail && this.#failed) {
        suite.stack.forEach((groupOrTest) => {
          if (groupOrTest instanceof Group) {
            groupOrTest.tap((t) => t.skip(true, "Skipped due to bail mode"));
          } else {
            groupOrTest.skip(true, "Skipped due to bail mode");
          }
        });
      }
      await suite.exec();
      if (!this.#failed && suite.failed) {
        this.#failed = true;
      }
    }
  }
  /**
   * End the runner process. Emits "runner:end" event
   */
  async end() {
    await this.#notifyEnd();
  }
};

// src/test/main.ts
import Hooks2 from "@poppinss/hooks";
import Macroable3 from "@poppinss/macroable";

// src/test/runner.ts
import retry from "async-retry";
import timeSpan2 from "time-span";

// src/interpolate.ts
function parseProp(data, key) {
  const tokens = key.split(".");
  while (tokens.length) {
    if (data === null || typeof data !== "object") {
      return;
    }
    const token = tokens.shift();
    data = Object.hasOwn(data, token) ? data[token] : void 0;
  }
  return data;
}
function interpolate(input, data, index) {
  return input.replace(/(\\)?{(.*?)}/g, (_, escapeChar, key) => {
    if (escapeChar) {
      return `{${key}}`;
    }
    key = key.trim();
    if (key === "$i") {
      return index;
    }
    if (key === "$self") {
      return data;
    }
    return parseProp(data, key);
  });
}

// src/test/runner.ts
var DummyRunner = class {
  #test;
  #emitter;
  /**
   * Know if the test has failed
   */
  get failed() {
    return false;
  }
  constructor(test, emitter) {
    this.#test = test;
    this.#emitter = emitter;
  }
  /**
   * Notify the reporter about the test start
   */
  #notifyStart() {
    const startOptions = {
      ...this.#test.options,
      title: {
        original: this.#test.options.title,
        expanded: this.#test.options.title
      },
      isPinned: this.#test.isPinned
    };
    this.#emitter.emit("test:start", startOptions);
  }
  /**
   * Notify the reporter about the test start
   */
  #notifyEnd() {
    const endOptions = {
      ...this.#test.options,
      title: {
        original: this.#test.options.title,
        expanded: this.#test.options.title
      },
      isPinned: this.#test.isPinned,
      hasError: false,
      duration: 0,
      errors: []
    };
    this.#emitter.emit("test:end", endOptions);
  }
  /**
   * Run test
   */
  run() {
    this.#notifyStart();
    this.#notifyEnd();
  }
};
var TestRunner = class {
  #emitter;
  #debuggingError;
  /**
   * Timeout timer and promise reject method references to
   * fail the test after timeout. We keep global reference
   * to allow timeout reset within the test.
   */
  #timeout;
  /**
   * Time tracker to find test duration
   */
  #timeTracker;
  /**
   * Reference to the startup runner
   */
  #setupRunner;
  /**
   * Reference to the cleanup runner
   */
  #teardownRunner;
  /**
   * Test errors
   */
  #errors = [];
  /**
   * Track if test has any errors
   */
  #hasError = false;
  /**
   * Current dataset index for which executing the test
   */
  #datasetCurrentIndex;
  /**
   * Callbacks to execute around the test executor
   */
  #callbacks;
  /**
   * Reference to parent test
   */
  #test;
  /**
   * Need access to hooks so that we can grab an instance of
   * "cleanup" runner.
   *
   * The cleanup runner should be fetched post running the test callback,
   * since that callback can push hooks to the cleanup event.
   */
  #hooks;
  /**
   * Know if the test has failed
   */
  get failed() {
    return this.#hasError;
  }
  constructor(test, hooks, emitter, callbacks, debuggingError, datasetCurrentIndex) {
    this.#test = test;
    this.#hooks = hooks;
    this.#emitter = emitter;
    this.#callbacks = callbacks;
    this.#debuggingError = debuggingError;
    this.#datasetCurrentIndex = datasetCurrentIndex;
    this.#setupRunner = hooks.runner("setup");
    this.#teardownRunner = hooks.runner("teardown");
  }
  /**
   * Returns the dataset node for the test events
   */
  #getDatasetNode() {
    if (this.#datasetCurrentIndex !== void 0 && this.#test.dataset) {
      return {
        dataset: {
          row: this.#test.dataset[this.#datasetCurrentIndex],
          index: this.#datasetCurrentIndex,
          size: this.#test.dataset.length
        }
      };
    }
  }
  /**
   * Get the title node for the test
   */
  #getTitle(dataset) {
    const title = this.#test.options.title;
    return {
      original: title,
      expanded: dataset ? interpolate(title, dataset.row, dataset.index + 1) : title
    };
  }
  /**
   * Notify the reporter about the test start
   */
  #notifyStart() {
    this.#timeTracker = timeSpan2();
    const dataset = this.#getDatasetNode();
    const startOptions = {
      ...this.#test.options,
      ...dataset,
      isPinned: this.#test.isPinned,
      title: this.#getTitle(dataset ? dataset.dataset : void 0)
    };
    this.#emitter.emit("test:start", startOptions);
  }
  /**
   * Creates an error to be used for reporting errors with the
   * execution of the test.
   *
   * First, the `debuggingError` property is used (if exists), otherwise
   * an inline Error instance is created
   */
  #createError(message) {
    if (this.#debuggingError) {
      this.#debuggingError.message = message;
      return this.#debuggingError;
    }
    return new Error(message);
  }
  /**
   * Notify the reporter about the test start
   */
  #notifyEnd() {
    const dataset = this.#getDatasetNode();
    const endOptions = {
      ...this.#test.options,
      ...dataset,
      isPinned: this.#test.isPinned,
      title: this.#getTitle(dataset ? dataset.dataset : void 0),
      hasError: this.#hasError,
      errors: this.#errors,
      retryAttempt: this.#test.options.retryAttempt,
      duration: this.#timeTracker?.() ?? 0
    };
    this.#emitter.emit("test:end", endOptions);
  }
  /**
   * Running setup hooks
   */
  async #runSetupHooks() {
    try {
      debug_default('running "%s" test setup hooks', this.#test.title);
      await this.#setupRunner.run(this.#test);
    } catch (error) {
      debug_default("test setup hooks failed, test: %s, error: %O", this.#test.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "setup", error });
    }
  }
  /**
   * Running teardown hooks
   */
  async #runTeardownHooks() {
    try {
      debug_default('running "%s" test teardown hooks', this.#test.title);
      await this.#teardownRunner.run(this.#test);
    } catch (error) {
      debug_default("test teardown hooks failed, test: %s, error: %O", this.#test.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "teardown", error });
    }
  }
  /**
   * Running test cleanup functions
   */
  async #runTestCleanupFunctions() {
    const cleanupRunner = this.#hooks.runner("cleanup");
    this.#hooks.clear("cleanup");
    try {
      debug_default('running "%s" test cleanup functions', this.#test.title);
      await cleanupRunner.runReverse(this.#hasError, this.#test);
    } catch (error) {
      debug_default("test cleanup functions failed, test: %s, error: %O", this.#test.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "test:cleanup", error });
    }
  }
  /**
   * Running setup cleanup functions
   */
  async #runSetupCleanupFunctions() {
    try {
      debug_default('running "%s" test setup cleanup functions', this.#test.title);
      await this.#setupRunner.cleanup(this.#hasError, this.#test);
    } catch (error) {
      debug_default("test setup cleanup functions failed, test: %s, error: %O", this.#test.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "setup:cleanup", error });
    }
  }
  /**
   * Running teardown cleanup functions
   */
  async #runTeardownCleanupFunctions() {
    try {
      debug_default('running "%s" test teardown cleanup functions', this.#test.title);
      await this.#teardownRunner.cleanup(this.#hasError, this.#test);
    } catch (error) {
      debug_default("test teardown cleanup functions failed, test: %s, error: %O", this.#test.title, error);
      this.#hasError = true;
      this.#errors.push({ phase: "teardown:cleanup", error });
    }
  }
  /**
   * Run the test executor. The method takes care of passing
   * dataset row to the test method
   */
  async #runTest(done) {
    const datasetRow = this.#datasetCurrentIndex !== void 0 && this.#test.dataset ? this.#test.dataset[this.#datasetCurrentIndex] : void 0;
    return datasetRow !== void 0 ? this.#test.options.executor(this.#test.context, datasetRow, done) : this.#test.options.executor(this.#test.context, done);
  }
  /**
   * Run the test executor that relies on the done method. The test will
   * timeout if done isn't called.
   */
  #runTestWithDone() {
    return new Promise((resolve, reject) => {
      const done = (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      };
      debug_default('running test "%s" and waiting for done method call', this.#test.title);
      this.#runTest(done).catch(reject);
    });
  }
  /**
   * Creates a timeout promise with global timer to reject
   * the promise after given duration.
   */
  #createTimeoutTimer(duration) {
    return new Promise((_, reject) => {
      debug_default("wrapping test in timeout timer");
      this.#timeout = {
        reject,
        timer: setTimeout(() => this.#timeout.reject(this.#createError("Test timeout")), duration)
      };
    });
  }
  /**
   * Resets the timeout timer
   */
  #resetTimer(duration) {
    if (this.#timeout) {
      debug_default("resetting timer");
      clearTimeout(this.#timeout.timer);
      this.#timeout.timer = setTimeout(
        () => this.#timeout.reject(this.#createError("Test timeout")),
        duration
      );
    }
  }
  /**
   * Clears the timer
   */
  #clearTimer() {
    if (this.#timeout) {
      debug_default("clearing timer");
      clearTimeout(this.#timeout.timer);
      this.#timeout = void 0;
    }
  }
  /**
   * Reverts the failing/passing behavior of the test
   * if it is meant to be a regression test
   */
  #wrapRegressionTest() {
    if (!this.#test.options.isFailing) {
      return this.#test.options.waitsForDone ? this.#runTestWithDone() : this.#runTest();
    }
    return new Promise((resolve, reject) => {
      ;
      (this.#test.options.waitsForDone ? this.#runTestWithDone() : this.#runTest()).then(() => {
        reject(
          this.#createError(
            "Expected regression test to fail, instead it finished without any errors"
          )
        );
      }).catch(() => resolve());
    });
  }
  /**
   * Run the test executor and make sure it times out after the configured
   * timeout.
   */
  async #wrapTestInTimeout() {
    if (!this.#test.options.timeout) {
      return this.#wrapRegressionTest();
    }
    try {
      await Promise.race([
        this.#createTimeoutTimer(this.#test.options.timeout),
        this.#wrapRegressionTest()
      ]);
    } finally {
      this.#clearTimer();
    }
  }
  /**
   * Runs the test with retries in place
   */
  #wrapTestInRetries() {
    if (!this.#test.options.retries) {
      return this.#wrapTestInTimeout();
    }
    return retry(
      (_, attempt) => {
        this.#test.options.retryAttempt = attempt;
        return this.#wrapTestInTimeout();
      },
      { retries: this.#test.options.retries, factor: 1 }
    );
  }
  /**
   * Reset test timeout. The timeout will be removed, if
   * no duration value is provided
   */
  resetTimeout(duration) {
    if (!duration) {
      this.#clearTimer();
    } else {
      this.#resetTimer(duration);
    }
  }
  /**
   * Run the test
   */
  async run() {
    debug_default('starting to run "%s" test', this.#test.title);
    this.#notifyStart();
    await this.#runSetupHooks();
    if (this.#hasError) {
      await this.#runSetupCleanupFunctions();
      this.#notifyEnd();
      return;
    }
    try {
      this.#callbacks.executing.forEach((callback) => callback(this.#test));
      await this.#wrapTestInRetries();
    } catch (error) {
      this.#hasError = true;
      this.#errors.push({ phase: "test", error });
    }
    this.#callbacks.executed.forEach((callback) => {
      try {
        callback(this.#test, this.#hasError, this.#errors);
      } catch (error) {
        this.#hasError = true;
        this.#errors.push({ phase: "test", error });
      }
    });
    await this.#runTestCleanupFunctions();
    await this.#runSetupCleanupFunctions();
    await this.#runTeardownHooks();
    await this.#runTeardownCleanupFunctions();
    this.#notifyEnd();
  }
};

// src/test/main.ts
var Test = class extends Macroable3 {
  constructor(title, context, emitter, refiner, parent) {
    super();
    this.title = title;
    this.parent = parent;
    this.#emitter = emitter;
    this.#refiner = refiner;
    this.options = {
      title: this.title,
      tags: [],
      timeout: 2e3,
      meta: {}
    };
    if (!this.constructor.hasOwnProperty("executingCallbacks")) {
      throw new Error(
        `Define static property "executingCallbacks = []" on ${this.constructor.name} class`
      );
    }
    if (!this.constructor.hasOwnProperty("executedCallbacks")) {
      throw new Error(
        `Define static property "executedCallbacks = []" on ${this.constructor.name} class`
      );
    }
    if (typeof context === "function") {
      this.#contextAccumlator = context;
    } else {
      this.context = context;
    }
  }
  /**
   * Methods to call before the test callback is executed
   */
  static executingCallbacks = [];
  /**
   * Methods to call after the test callback is executed
   */
  static executedCallbacks = [];
  /**
   * Define a synchronous function to call before running
   * the test executor callback
   *
   * Do note: Async methods are not allowed
   */
  static executing(callback) {
    this.executingCallbacks.push(callback);
  }
  /**
   * Define a synchronous function to call after running
   * the test executor callback
   *
   * Do note: Async methods are not allowed
   */
  static executed(callback) {
    this.executedCallbacks.push(callback);
  }
  #refiner;
  #emitter;
  /**
   * Reference to the active runner running the
   * test
   */
  #activeRunner;
  /**
   * Check if the test has been executed
   */
  #executed = false;
  #failed = false;
  /**
   * Debugging Error is used to point the errors to the source of
   * the test.
   *
   * Since tests are executed after they are created, the errors thrown
   * by the internals of Japa will never point to the original test.
   * Therefore, this debuggingError property is used to retain
   * the source of the test callback.
   */
  #debuggingError = null;
  /**
   * Reference to registered hooks
   */
  #hooks = new Hooks2();
  /**
   * The function for creating the test context
   */
  #contextAccumlator;
  /**
   * The function for computing if test should
   * be skipped or not
   */
  #skipAccumulator;
  /**
   * The function that returns the test data set
   */
  #datasetAccumlator;
  /**
   * Know if the test has been executed. Skipped and
   * todo tests are also considered executed.
   */
  get executed() {
    return this.#executed;
  }
  /**
   * Know if the test has failed.
   */
  get failed() {
    return this.#failed;
  }
  /**
   * Test options
   */
  options;
  /**
   * Reference to the test dataset
   */
  dataset;
  /**
   * Reference to the test context. Available at the time
   * of running the test
   */
  context;
  /**
   * Find if the test is pinned
   */
  get isPinned() {
    return this.#refiner.isPinned(this);
  }
  /**
   * Find if test should be skipped
   */
  async #computeShouldSkip() {
    if (this.#skipAccumulator) {
      this.options.isSkipped = await this.#skipAccumulator();
    }
  }
  /**
   * Find if test is a todo
   */
  #computeisTodo() {
    this.options.isTodo = !this.options.executor;
  }
  /**
   * Returns the dataset array or undefined
   */
  async #computeDataset() {
    if (typeof this.#datasetAccumlator === "function") {
      this.dataset = await this.#datasetAccumlator();
    }
    return this.dataset;
  }
  /**
   * Get context instance for the test
   */
  async #computeContext() {
    if (typeof this.#contextAccumlator === "function") {
      this.context = await this.#contextAccumlator(this);
    }
    return this.context;
  }
  /**
   * Skip the test conditionally
   */
  skip(skip = true, skipReason) {
    if (typeof skip === "function") {
      this.#skipAccumulator = skip;
    } else {
      this.options.isSkipped = skip;
    }
    this.options.skipReason = skipReason;
    return this;
  }
  /**
   * Expect the test to fail. Helpful in creating test cases
   * to showcase bugs
   */
  fails(failReason) {
    this.options.isFailing = true;
    this.options.failReason = failReason;
    return this;
  }
  /**
   * Define custom timeout for the test
   */
  timeout(timeout) {
    this.options.timeout = timeout;
    return this;
  }
  /**
   * Disable test timeout. It is same as calling `test.timeout(0)`
   */
  disableTimeout() {
    return this.timeout(0);
  }
  /**
   * Reset the timeout from within the test callback.
   */
  resetTimeout(duration) {
    if (this.#activeRunner) {
      this.#activeRunner.resetTimeout(duration);
    } else {
      if (duration) {
        this.timeout(duration);
      } else {
        this.disableTimeout();
      }
    }
    return this;
  }
  /**
   * Assign tags to the test. Later you can use the tags to run
   * specific tests
   */
  tags(tags, strategy = "replace") {
    if (strategy === "replace") {
      this.options.tags = tags;
      return this;
    }
    if (strategy === "prepend") {
      this.options.tags = tags.concat(this.options.tags);
      return this;
    }
    this.options.tags = this.options.tags.concat(tags);
    return this;
  }
  /**
   * Configure the number of times this test should be retried
   * when failing.
   */
  retry(retries) {
    this.options.retries = retries;
    return this;
  }
  /**
   * Wait for the test executor to call done method
   */
  waitForDone() {
    this.options.waitsForDone = true;
    return this;
  }
  /**
   * Pin current test. Pinning a test will only run the
   * pinned tests.
   */
  pin() {
    this.#refiner.pinTest(this);
    return this;
  }
  /**
   * Define the dataset for the test. The test executor will be invoked
   * for all the items inside the dataset array
   */
  with(dataset) {
    if (Array.isArray(dataset)) {
      this.dataset = dataset;
      return this;
    }
    if (typeof dataset === "function") {
      this.#datasetAccumlator = dataset;
      return this;
    }
    throw new Error("dataset must be an array or a function that returns an array");
  }
  /**
   * Define the test executor function
   */
  run(executor, debuggingError) {
    this.#debuggingError = debuggingError || new Error();
    this.options.executor = executor;
    return this;
  }
  /**
   * Register a test setup function
   */
  setup(handler) {
    debug_default('registering "%s" test setup hook %s', this.title, handler);
    this.#hooks.add("setup", handler);
    return this;
  }
  /**
   * Register a test teardown function
   */
  teardown(handler) {
    debug_default('registering "%s" test teardown hook %s', this.title, handler);
    this.#hooks.add("teardown", handler);
    return this;
  }
  /**
   * Register a cleanup hook from within the test
   */
  cleanup(handler) {
    debug_default('registering "%s" test cleanup function %s', this.title, handler);
    this.#hooks.add("cleanup", handler);
    return this;
  }
  /**
   * Execute test
   */
  async exec() {
    const self = this.constructor;
    if (!this.#refiner.allows(this)) {
      debug_default('test "%s" skipped by refiner', this.title);
      return;
    }
    if (this.#executed) {
      return;
    }
    this.#executed = true;
    this.#computeisTodo();
    if (this.options.isTodo) {
      debug_default('skipping todo test "%s"', this.title);
      new DummyRunner(this, this.#emitter).run();
      return;
    }
    await this.#computeShouldSkip();
    if (this.options.isSkipped) {
      debug_default(
        'skipping test "%s", reason (%s)',
        this.title,
        this.options.skipReason || "Skipped using .skip method"
      );
      new DummyRunner(this, this.#emitter).run();
      return;
    }
    await this.#computeDataset();
    if (Array.isArray(this.dataset) && this.dataset.length) {
      let index = 0;
      for (let _ of this.dataset) {
        await this.#computeContext();
        this.#activeRunner = new TestRunner(
          this,
          this.#hooks,
          this.#emitter,
          {
            executing: self.executingCallbacks,
            executed: self.executedCallbacks
          },
          this.#debuggingError,
          index
        );
        await this.#activeRunner.run();
        if (!this.#failed && this.#activeRunner.failed) {
          this.#failed = true;
        }
        index++;
      }
      this.#activeRunner = void 0;
      return;
    }
    await this.#computeContext();
    this.#activeRunner = new TestRunner(
      this,
      this.#hooks,
      this.#emitter,
      {
        executing: self.executingCallbacks,
        executed: self.executedCallbacks
      },
      this.#debuggingError
    );
    await this.#activeRunner.run();
    this.#failed = this.#activeRunner.failed;
    this.#activeRunner = void 0;
  }
};

// src/emitter.ts
import Emittery from "emittery";
var Emitter = class extends Emittery {
  #errorHandler;
  /**
   * Define onError handler invoked when `emit` fails
   */
  onError(errorHandler) {
    this.#errorHandler = errorHandler;
  }
  /**
   * Emit event
   */
  async emit(eventName, eventData, allowMetaEvents) {
    try {
      await super.emit(eventName, eventData, allowMetaEvents);
    } catch (error) {
      if (this.#errorHandler) {
        await this.#errorHandler(error);
      } else {
        throw error;
      }
    }
  }
};

// src/refiner.ts
var Refiner = class {
  /**
   * Controls if test tags should match all the defined
   * tags or not.
   *
   * Defaults to false
   */
  #shouldMatchAllTags = false;
  /**
   * A set of pinned tests
   */
  #pinnedTests = /* @__PURE__ */ new Set();
  /**
   * Available filters
   */
  #filters = {
    tags: [],
    tests: [],
    groups: [],
    negatedTags: []
  };
  constructor(filters = {}) {
    if (filters.tags) {
      this.add("tags", filters.tags);
    }
    if (filters.tests) {
      this.add("tests", filters.tests);
    }
    if (filters.groups) {
      this.add("groups", filters.groups);
    }
  }
  /**
   * Find if the group is allowed to execute its tests.
   */
  #isGroupAllowed(group) {
    const groupFilters = this.#filters.groups;
    if (groupFilters.length && !groupFilters.includes(group.title)) {
      return false;
    }
    let allowGroup = false;
    for (let test of group.tests) {
      allowGroup = this.allows(test);
      if (allowGroup) {
        break;
      }
    }
    return allowGroup;
  }
  /**
   * Find if the test is allowed to be executed by checking
   * for the test title filter
   */
  #isTestTitleAllowed(test) {
    if (!this.#filters.tests.length) {
      return true;
    }
    return this.#filters.tests.includes(test.title);
  }
  /**
   * Find if test is allowed by the negated tags filter
   */
  #allowedByNegatedTags(test) {
    if (!this.#filters.negatedTags.length) {
      return true;
    }
    return this.#filters.negatedTags.every((tag) => !test.options.tags.includes(tag));
  }
  /**
   * Test if the test is allowed by the tags filter
   */
  #allowedByTags(test) {
    if (!this.#filters.tags.length) {
      return true;
    }
    if (this.#shouldMatchAllTags) {
      return this.#filters.tags.every((tag) => test.options.tags.includes(tag));
    }
    return this.#filters.tags.some((tag) => test.options.tags.includes(tag));
  }
  /*
   * Find if the test is allowed to be executed by checking
   * for the test tags
   */
  #areTestTagsAllowed(test) {
    return this.#allowedByTags(test) && this.#allowedByNegatedTags(test);
  }
  /*
   * Find if the test is allowed to be executed by checking
   * for the pinned tests
   */
  #isAllowedByPinnedTest(test) {
    if (!this.#pinnedTests.size) {
      return true;
    }
    return this.#pinnedTests.has(test);
  }
  /**
   * Enable/disable matching of all tags when filtering tests.
   * If "matchAll" is enabled, the test tags should match
   * all the user defined tags.
   *
   * Otherwise, any one match will pass the filter
   */
  matchAllTags(state) {
    this.#shouldMatchAllTags = state;
    return this;
  }
  /**
   * Pin a test to be executed.
   */
  pinTest(test) {
    this.#pinnedTests.add(test);
  }
  /**
   * Find if a test is pinned
   */
  isPinned(test) {
    return this.#pinnedTests.has(test);
  }
  /**
   * Add a filter
   */
  add(layer, values) {
    if (layer === "tags") {
      values.forEach((tag) => {
        if (tag.startsWith("!") || tag.startsWith("~")) {
          this.#filters.negatedTags.push(tag.slice(1));
        } else {
          this.#filters.tags.push(tag);
        }
      });
    } else {
      this.#filters[layer].push(...values);
    }
  }
  /**
   * Check if refiner allows a specific test or group to run by looking
   * at the applied filters
   */
  allows(testOrGroup) {
    if (testOrGroup instanceof Group) {
      return this.#isGroupAllowed(testOrGroup);
    }
    if (this.#filters.groups.length && !testOrGroup.parent) {
      return false;
    }
    const isTestTitleAllowed = this.#isTestTitleAllowed(testOrGroup);
    if (!isTestTitleAllowed) {
      return false;
    }
    const areTestTagsAllowed = this.#areTestTagsAllowed(testOrGroup);
    if (!areTestTagsAllowed) {
      return false;
    }
    return this.#isAllowedByPinnedTest(testOrGroup);
  }
};

// src/suite/main.ts
import Hooks3 from "@poppinss/hooks";
import Macroable4 from "@poppinss/macroable";

// src/suite/runner.ts
var SuiteRunner = class {
  #emitter;
  #options;
  /**
   * Parent suite reference
   */
  #suite;
  /**
   * Reference to the startup runner
   */
  #setupRunner;
  /**
   * Reference to the cleanup runner
   */
  #teardownRunner;
  /**
   * Test errors
   */
  #errors = [];
  /**
   * Track if test has any errors
   */
  #hasError = false;
  /**
   * Know if any of the tests/hooks have failed
   */
  get failed() {
    return this.#hasError;
  }
  constructor(suite, hooks, emitter, options) {
    this.#suite = suite;
    this.#emitter = emitter;
    this.#options = options;
    this.#setupRunner = hooks.runner("setup");
    this.#teardownRunner = hooks.runner("teardown");
  }
  /**
   * Notify the reporter about the suite start
   */
  #notifyStart() {
    const startOptions = { name: this.#suite.name };
    this.#emitter.emit("suite:start", startOptions);
  }
  /**
   * Notify the reporter about the suite end
   */
  #notifyEnd() {
    const endOptions = {
      name: this.#suite.name,
      hasError: this.#hasError,
      errors: this.#errors
    };
    this.#emitter.emit("suite:end", endOptions);
  }
  /**
   * Running setup hooks
   */
  async #runSetupHooks() {
    debug_default('running "%s" suite setup hooks', this.#suite.name);
    try {
      await this.#setupRunner.run(this.#suite);
    } catch (error) {
      debug_default("suite setup hooks failed, suite: %s, error: %O", this.#suite.name, error);
      this.#hasError = true;
      this.#errors.push({ phase: "setup", error });
    }
  }
  /**
   * Running teardown hooks
   */
  async #runTeardownHooks() {
    debug_default('running "%s" suite teardown hooks', this.#suite.name);
    try {
      await this.#teardownRunner.run(this.#suite);
    } catch (error) {
      debug_default("suite teardown hooks failed, suite: %s, error: %O", this.#suite.name, error);
      this.#hasError = true;
      this.#errors.push({ phase: "teardown", error });
    }
  }
  /**
   * Running setup cleanup functions
   */
  async #runSetupCleanupFunctions() {
    debug_default('running "%s" suite setup cleanup functions', this.#suite.name);
    try {
      await this.#setupRunner.cleanup(this.#hasError, this.#suite);
    } catch (error) {
      debug_default("suite setup cleanup functions failed, suite: %s, error: %O", this.#suite.name, error);
      this.#hasError = true;
      this.#errors.push({ phase: "setup:cleanup", error });
    }
  }
  /**
   * Running teardown cleanup functions
   */
  async #runTeardownCleanupFunctions() {
    debug_default('running "%s" suite teardown cleanup functions', this.#suite.name);
    try {
      await this.#teardownRunner.cleanup(this.#hasError, this.#suite);
    } catch (error) {
      debug_default(
        "suite teardown cleanup functions failed, suite: %s, error: %O",
        this.#suite.name,
        error
      );
      this.#hasError = true;
      this.#errors.push({ phase: "teardown:cleanup", error });
    }
  }
  /**
   * Run the test
   */
  async run() {
    debug_default('starting to run "%s" suite', this.#suite.name);
    this.#notifyStart();
    await this.#runSetupHooks();
    if (this.#hasError) {
      await this.#runSetupCleanupFunctions();
      this.#notifyEnd();
      return;
    }
    for (let groupOrTest of this.#suite.stack) {
      if (this.#options.bail && this.#hasError) {
        if (groupOrTest instanceof Group) {
          groupOrTest.tap((t) => t.skip(true, "Skipped due to bail mode"));
        } else {
          groupOrTest.skip(true, "Skipped due to bail mode");
        }
      }
      await groupOrTest.exec();
      if (!this.#hasError && groupOrTest.failed) {
        this.#hasError = true;
      }
    }
    await this.#runSetupCleanupFunctions();
    await this.#runTeardownHooks();
    await this.#runTeardownCleanupFunctions();
    this.#notifyEnd();
  }
};

// src/suite/main.ts
var Suite = class extends Macroable4 {
  constructor(name, emitter, refiner) {
    super();
    this.name = name;
    this.#emitter = emitter;
    this.#refiner = refiner;
  }
  #refiner;
  #emitter;
  #failed = false;
  #bail;
  /**
   * Reference to registered hooks
   */
  #hooks = new Hooks3();
  /**
   * Callbacks to invoke on each test and group
   */
  #configureTestCallbacks = [];
  #configureGroupCallbacks = [];
  /**
   * A collection of tests and groups both
   */
  stack = [];
  /**
   * Know if one or more groups or tests within this suite
   * has failed.
   */
  get failed() {
    return this.#failed;
  }
  /**
   * Add a test or a group to the execution stack
   */
  add(testOrGroup) {
    if (testOrGroup instanceof Group) {
      this.#configureGroupCallbacks.forEach((callback) => callback(testOrGroup));
    }
    if (testOrGroup instanceof Test) {
      this.#configureTestCallbacks.forEach((callback) => callback(testOrGroup));
    }
    this.stack.push(testOrGroup);
    return this;
  }
  /**
   * Tap into each test and configure it
   */
  onTest(callback) {
    this.stack.forEach((testOrGroup) => {
      if (testOrGroup instanceof Test) {
        callback(testOrGroup);
      }
    });
    this.#configureTestCallbacks.push(callback);
    return this;
  }
  /**
   * Tap into each group and configure it
   */
  onGroup(callback) {
    this.stack.forEach((testOrGroup) => {
      if (testOrGroup instanceof Group) {
        callback(testOrGroup);
      }
    });
    this.#configureGroupCallbacks.push(callback);
    return this;
  }
  /**
   * Enable/disable the bail mode. In bail mode, all
   * upcoming tests/group will be skipped when the current
   * test fails
   */
  bail(toggle = true) {
    if (this.#bail === void 0) {
      this.#bail = toggle;
      this.onGroup((group) => group.bail(toggle));
    }
    return this;
  }
  /**
   * Register a test setup function
   */
  setup(handler) {
    debug_default("registering suite setup hook %s", handler);
    this.#hooks.add("setup", handler);
    return this;
  }
  /**
   * Register a test teardown function
   */
  teardown(handler) {
    debug_default("registering suite teardown hook %s", handler);
    this.#hooks.add("teardown", handler);
    return this;
  }
  /**
   * Execute suite groups, tests and hooks
   */
  async exec() {
    let allowSuite = false;
    for (let item of this.stack) {
      allowSuite = this.#refiner.allows(item);
      if (allowSuite) {
        break;
      }
    }
    if (!allowSuite) {
      debug_default("suite disabled by refiner %s", this.name);
      return;
    }
    const runner = new SuiteRunner(this, this.#hooks, this.#emitter, {
      bail: this.#bail ?? false
    });
    await runner.run();
    this.#failed = runner.failed;
  }
};

// src/test_context.ts
import { inspect } from "node:util";
import Macroable5 from "@poppinss/macroable";
var TestContext = class extends Macroable5 {
  [inspect.custom]() {
    return inspect(this, { showHidden: false, depth: 1, colors: true, customInspect: false });
  }
};
export {
  Emitter,
  Group,
  Refiner,
  Runner,
  Suite,
  Test,
  TestContext,
  Tracker
};
